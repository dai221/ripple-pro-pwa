<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#0EA5E9">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Ripple Pro Calm (fixed)</title>
  <style>
    html,body {margin:0;height:100%;background:#060C18;overflow:hidden}
    canvas {display:block;width:100vw;height:100vh;touch-action:none}
    .ui {
      position:fixed;left:10px;top:10px;z-index:10;display:flex;gap:8px;align-items:center;
      background:rgba(0,0,0,.35);backdrop-filter:blur(8px);padding:8px 10px;border-radius:12px;
      color:#E6F2FF;font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;font-size:12px
    }
    select, input[type=range] {
      background:rgba(255,255,255,.06);color:#E6F2FF;border:1px solid rgba(255,255,255,.18);
      padding:4px;border-radius:8px
    }
    .brand {position:fixed;right:10px;bottom:10px;color:#9BD3FF;opacity:.75;font-size:12px;font-family:ui-sans-serif,system-ui}
    .hint {position:fixed;left:50%;bottom:12px;transform:translateX(-50%);color:#CFE8FF;opacity:.85;font-size:12px;font-family:ui-sans-serif,system-ui}
    .fallback {position:fixed;inset:0;display:flex;align-items:center;justify-content:center;color:#cde8ff;font-family:ui-sans-serif,system-ui}
  </style>
</head>
<body>
  <div class="ui">
    <label>テーマ
      <select id="theme">
        <option value="aurora">Aurora Flow</option>
        <option value="water" selected>Water Caustics</option>
        <option value="petals">Sakura Drift</option>
      </select>
    </label>
    強度 <input id="intensity" type="range" min="0" max="100" value="50">
    <a id="fs" href="#" style="text-decoration:none;background:#0EA5E9;color:white;padding:4px 8px;border-radius:10px;font-weight:700">全画面</a>
  </div>
  <div class="hint">タップで干渉・波紋。二本指で強め。更新が出ない時は再読み込み。</div>
  <div class="brand">Ripple Pro Calm</div>
  <canvas id="gl"></canvas>
  <div class="fallback" id="fallback" style="display:none">WebGLが無効のため2D描画に切り替えました。</div>
<script>
const canvas = document.getElementById('gl');
let gl = canvas.getContext('webgl', {antialias:true, alpha:false});
const DPR = Math.min(devicePixelRatio || 1, 2);
function resize(){ canvas.width = Math.floor(innerWidth*DPR); canvas.height = Math.floor(innerHeight*DPR); if(gl) gl.viewport(0,0,canvas.width,canvas.height); }
addEventListener('resize', resize, {passive:true}); resize();

function enableDerivatives(gl){ const ext = gl.getExtension('OES_standard_derivatives'); return !!ext; }

const vsSrc = `attribute vec2 p;
void main(){ gl_Position = vec4(p,0.0,1.0); }`;
const fsAurora = `precision highp float;
uniform vec2 u_res; uniform float u_time; uniform vec2 u_tap; uniform float u_force;
float N21(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233)))*43758.5453); }
vec2 hash2(vec2 p){ p = vec2(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3))); return -1.0 + 2.0*fract(sin(p)*43758.5453123); }
float noise(vec2 p){
  vec2 i = floor(p), f = fract(p);
  float a = dot(hash2(i+vec2(0,0)), f-vec2(0,0));
  float b = dot(hash2(i+vec2(1,0)), f-vec2(1,0));
  float c = dot(hash2(i+vec2(0,1)), f-vec2(0,1));
  float d = dot(hash2(i+vec2(1,1)), f-vec2(1,1));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}
float fbm(vec2 p){
  float s = 0.0, a = 0.5;
  for(int i=0;i<5;i++){ s+=a*noise(p); p*=2.0; a*=0.5; }
  return s;
}
vec3 tonemap(vec3 c){ c = max(c,0.0); return c/(1.0+c); }
void main(){
  vec2 uv = gl_FragCoord.xy / u_res;
  vec2 p = (gl_FragCoord.xy - 0.5*u_res) / u_res.y;
  float f = fbm(p*1.2 + vec2(0.0, u_time*0.05));
  float g = fbm(p*2.4 - vec2(u_time*0.03, 0.0));
  float a = smoothstep(0.2, 0.9, f) * 0.9 + 0.1;
  float b = smoothstep(0.1, 0.8, g);
  float ripple = 0.0;
  if(u_tap.x >= 0.0){
    vec2 tp = (u_tap - gl_FragCoord.xy)/u_res.y;
    float d = length(tp);
    ripple = 0.15 * sin(40.0*d - u_time*5.0) * exp(-4.0*d) * u_force;
  }
  vec3 col = vec3(0.02,0.10,0.18);
  col += vec3(0.1,0.5,0.9) * a * 0.8;
  col += vec3(0.7,0.9,1.2) * b * 0.6;
  col += vec3(0.3,0.7,1.0) * ripple;
  float v = smoothstep(1.1, 0.2, length(p));
  col *= v;
  gl_FragColor = vec4(tonemap(col), 1.0);
}`;
const fsWater = `#extension GL_OES_standard_derivatives : enable
precision highp float;
uniform vec2 u_res; uniform float u_time; uniform vec2 u_tap; uniform float u_force;
float N21(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233)))*43758.5453); }
vec2 hash2(vec2 p){ p = vec2(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3))); return -1.0 + 2.0*fract(sin(p)*43758.5453123); }
float noise(vec2 p){
  vec2 i = floor(p), f = fract(p);
  float a = dot(hash2(i+vec2(0,0)), f-vec2(0,0));
  float b = dot(hash2(i+vec2(1,0)), f-vec2(1,0));
  float c = dot(hash2(i+vec2(0,1)), f-vec2(0,1));
  float d = dot(hash2(i+vec2(1,1)), f-vec2(1,1));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}
float fbm(vec2 p){
  float s = 0.0, a = 0.5;
  for(int i=0;i<5;i++){ s+=a*noise(p); p*=2.0; a*=0.5; }
  return s;
}
vec3 tonemap(vec3 c){ c = max(c,0.0); return c/(1.0+c); }
void main(){
  vec2 uv = gl_FragCoord.xy / u_res;
  vec2 p = (gl_FragCoord.xy - 0.5*u_res) / u_res.y;
  vec3 base = mix(vec3(0.03,0.12,0.25), vec3(0.04,0.25,0.45), uv.y);
  float t = u_time;
  float H = 0.0;
  H += 0.40*sin(p.x*7.0 + t*1.3);
  H += 0.25*sin(p.y*9.0 - t*1.7);
  H += 0.20*sin((p.x+p.y)*11.0 + t*1.1);
  H += 0.15*fbm(p*6.0 + vec2(t*0.2, -t*0.15));
  if(u_tap.x >= 0.0){
    vec2 tp = (u_tap - gl_FragCoord.xy)/u_res.y;
    float d = length(tp);
    H += 0.25 * sin(35.0*d - t*6.0) * exp(-3.0*d) * u_force;
  }
  float dx = dFdx(H);
  float dy = dFdy(H);
  vec3 n = normalize(vec3(-dx, -dy, 1.0));
  vec3 L = normalize(vec3(0.6, 0.4, 0.7));
  float diff = max(0.0, dot(n, L));
  float spec = pow(max(0.0, dot(reflect(-L, n), vec3(0.0,0.0,1.0))), 48.0);
  float cst = smoothstep(0.6, 1.0, diff) * 0.6;
  vec3 col = base + diff*vec3(0.05,0.20,0.40) + spec*vec3(0.8,0.9,1.0) + cst*vec3(0.1,0.5,1.0);
  float grain = N21(gl_FragCoord.xy)*0.02;
  col += grain;
  float v = smoothstep(1.15, 0.2, length(p));
  col *= v;
  gl_FragColor = vec4(tonemap(col), 1.0);
}`;
const fsPetals = `precision highp float;
uniform vec2 u_res; uniform float u_time; uniform vec2 u_tap; uniform float u_force;
float N21(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233)))*43758.5453); }
vec2 hash2(vec2 p){ p = vec2(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3))); return -1.0 + 2.0*fract(sin(p)*43758.5453123); }
float noise(vec2 p){
  vec2 i = floor(p), f = fract(p);
  float a = dot(hash2(i+vec2(0,0)), f-vec2(0,0));
  float b = dot(hash2(i+vec2(1,0)), f-vec2(1,0));
  float c = dot(hash2(i+vec2(0,1)), f-vec2(0,1));
  float d = dot(hash2(i+vec2(1,1)), f-vec2(1,1));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}
float fbm(vec2 p){
  float s = 0.0, a = 0.5;
  for(int i=0;i<5;i++){ s+=a*noise(p); p*=2.0; a*=0.5; }
  return s;
}
vec3 tonemap(vec3 c){ c = max(c,0.0); return c/(1.0+c); }
float petal(vec2 p){
  p.y *= 1.3;
  float r = length(p);
  float ang = atan(p.y, p.x);
  float heart = r - 0.25*(1.0 + 0.3*cos(6.0*ang));
  return smoothstep(0.16, 0.15, heart);
}
void main(){
  vec2 uv = gl_FragCoord.xy / u_res;
  vec2 p = (gl_FragCoord.xy - 0.5*u_res) / u_res.y;
  vec3 bg = mix(vec3(0.02,0.05,0.10), vec3(0.10,0.15,0.25), uv.y);
  vec3 col = bg;
  for(int i=0;i<40;i++){
    float fi = float(i);
    float phase = fract(sin(fi*12.345)*4567.89);
    vec2 pos = vec2(fract(phase + u_time*0.02 + float(i)*0.017) - 0.5, fract(phase*1.7 - u_time*0.035 - float(i)*0.013));
    vec2 q = p - pos;
    float a = petal(q*1.4);
    vec3 pc = mix(vec3(0.97,0.78,0.86), vec3(0.95,0.65,0.80), fract(phase*9.0));
    col = mix(col, pc, a*0.9);
  }
  if(u_tap.x >= 0.0){
    vec2 tp = (u_tap - gl_FragCoord.xy)/u_res.y;
    float d = length(tp);
    float ring = 0.15 * sin(40.0*d - u_time*6.0) * exp(-4.0*d) * u_force;
    col += vec3(0.15,0.10,0.20) * ring;
  }
  col += pow(max(col-0.6,0.0), vec3(1.8));
  gl_FragColor = vec4(tonemap(col), 1.0);
}`;

function compile(gl, type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ throw gl.getShaderInfoLog(s); } return s; }
function program(gl, fs){ const p = gl.createProgram(); gl.attachShader(p, compile(gl, gl.VERTEX_SHADER, vsSrc)); gl.attachShader(p, compile(gl, gl.FRAGMENT_SHADER, fs)); gl.bindAttribLocation(p,0,'p'); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ throw gl.getProgramInfoLog(p); } return p; }

let use2D = false;
let ctx2d = null;
if(!gl){ // fallback
  use2D = true;
  document.getElementById('fallback').style.display = 'flex';
  ctx2d = canvas.getContext('2d');
}

let quad, progAurora, progWater, progPetals, current;
let tap=[-1,-1], tapDecay=0.0, force=0.5;

function initGL(){
  if(!enableDerivatives(gl)){ console.warn('OES_standard_derivatives not available; water shader may fail.'); }
  quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
  try{ progAurora = program(gl, fsAurora); } catch(e){ console.error('Aurora shader error:', e); }
  try{ progWater = program(gl, fsWater); } catch(e){ console.error('Water shader error:', e); }
  try{ progPetals = program(gl, fsPetals); } catch(e){ console.error('Petals shader error:', e); }
  current = progWater || progAurora || progPetals;
}

function use(gl, prog){ gl.useProgram(prog); const loc = gl.getAttribLocation(prog,'p'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0); }

function renderGL(t){ t*=0.001; const prog = current || progAurora || progPetals; if(!prog){ requestAnimationFrame(renderGL); return; } use(gl, prog);
  gl.uniform2f(gl.getUniformLocation(prog,'u_res'), canvas.width, canvas.height);
  gl.uniform1f(gl.getUniformLocation(prog,'u_time'), t);
  gl.uniform2f(gl.getUniformLocation(prog,'u_tap'), tap[0], tap[1]);
  gl.uniform1f(gl.getUniformLocation(prog,'u_force'), force*(0.5 + tapDecay));
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  tapDecay = Math.max(0.0, tapDecay - 0.02);
  requestAnimationFrame(renderGL);
}

function render2D(t){ t*=0.001; const ctx = ctx2d; const W = canvas.width, H = canvas.height; ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#082038'); g.addColorStop(1,'#0b3a66'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  for(let i=0;i<5;i++){ const y = H*(0.2+0.15*i) + Math.sin(t*0.5 + i)*H*0.05; ctx.globalAlpha = 0.12 + 0.05*Math.sin(t+i);
    ctx.fillStyle = ['#2dd4ff','#60a5fa','#a78bfa','#22d3ee','#93c5fd'][i%5]; ctx.fillRect(0, y, W, H*0.12); }
  requestAnimationFrame(render2D);
}

if(gl){ initGL(); requestAnimationFrame(renderGL); } else { requestAnimationFrame(render2D); }

const select = document.getElementById('theme');
const intensity = document.getElementById('intensity');
intensity.addEventListener('input', ()=>{ force = parseInt(intensity.value,10)/100; });
function onPoint(e){ const touches = e.touches ? e.touches.length : 0; const p = e.touches ? e.touches[0] : e; tap=[p.clientX*DPR, (innerHeight*DPR - p.clientY*DPR)]; tapDecay=Math.min(1.0, tapDecay + (touches>=2?0.8:0.4)); e.preventDefault(); }
canvas.addEventListener('pointerdown', onPoint, {passive:false});
canvas.addEventListener('pointermove', e=>{ if(e.buttons) onPoint(e); }, {passive:false});
canvas.addEventListener('touchstart', onPoint, {passive:false});
canvas.addEventListener('touchmove', onPoint, {passive:false});
document.getElementById('fs').addEventListener('click', (e)=>{ e.preventDefault(); if(document.fullscreenElement) document.exitFullscreen(); else canvas.requestFullscreen?.(); });
if('serviceWorker' in navigator){ addEventListener('load', ()=> navigator.serviceWorker.register('./sw.js')); }
select.addEventListener('change', ()=>{ const v = select.value; current = (v==='aurora')?progAurora: (v==='water'?progWater:progPetals); });
</script>
</body>
</html>
